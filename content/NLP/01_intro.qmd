---
title: "Quelques éléments pour comprendre les enjeux du NLP"
slug: nlpintro
type: book
tags:
  - NLP
  - nltk
  - Littérature
  - preprocessing
  - Tutoriel
categories:
  - NLP
  - Tutoriel
description: |
  Les corpus textuels étant des objets de très grande dimension
  où le ratio signal/bruit est faible, il est nécessaire de mettre
  en oeuvre une série d'étapes de nettoyage de texte. Ce chapitre va
  explorer quelques méthodes classiques de nettoyage en s'appuyant
  sur le _Comte de Monte Cristo_ d'Alexandre Dumas. 
bibliography: ../../reference.bib
image: https://minio.lab.sspcloud.fr/lgaliana/generative-art/pythonds/python-reading.jfif
echo: false
---

::: {.content-visible when-format="html"}
{{< include "../../build/_printBadges.qmd" >}}
:::

# Introduction

## Rappel

Comme évoqué dans l'[introduction de cette partie](/content/nlp/index.qmd) sur le traitement automatique du langage, l'objectif principal des techniques que nous allons explorer est la représentation synthétique du langage. 

Le *natural language processing* (NLP) ou
*traitement automatisé du langage* (TAL) en Français,
vise à extraire de l'information de textes à partir d'une analyse statistique du contenu. 
Cette définition permet d'inclure de nombreux champs d'applications au sein
du NLP (traduction, analyse de sentiment, recommandation, surveillance, etc. ). 

Cette approche implique de transformer un texte, qui est une information compréhensible par un humain, en un nombre, information appropriée pour un ordinateur dans le cadre d'une approche statistique ou algorithmique. 

Transformer une information textuelle en valeurs numériques propres à une analyse statistique n'est pas une tâche évidente. Les données textuelles sont **non structurées** puisque l'information cherchée, qui est propre à chaque analyse, est perdue au milieu d'une grande masse d'informations qui doit, de plus, être interprétée dans un certain contexte (un même mot ou une phrase n'ayant pas la même signification selon le contexte). 

Si cette tâche n'était pas assez difficile comme ça, on peut ajouter d'autres difficultés propres à l'analyse textuelle car ces données sont :

* **bruitées** : ortographe, fautes de frappe...
* **changeantes** : la langue évolue avec de nouveaux mots, sens...
* **complexes** : structures variables, accords...
* **ambiguës** : synonymie, polysémie, sens caché...
* **propres à chaque langue** : il n'existe pas de règle de passage unique entre deux langues
* de **grande dimension** : des combinaisons infinies de séquences de mots


## Objectif du chapitre

Dans ce chapitre, nous allons nous restreindre aux 
méthodes fréquentistes dans le paradigme _bag of words_. Celles-ci sont un peu _old school_ par rapport aux approches plus raffinées que nous évoquerons ultérieurement. Néanmoins, les présenter nous permettra d'évoquer un certain nombre d'enjeux typiques des données textuelles qui restent centraux dans le NLP moderne.

Le principal enseignement à retenir de cette partie est que les données textuelles étant à très haute dimension - le langage étant un objet riche - nous avons besoin de méthodes pour réduire le bruit de nos corpus textuels afin de mieux prendre en compte le signal en leur sein.  

Cette partie est une introduction s'appuyant sur quelques ouvrages classiques de la littérature française ou anglo-saxonne. Seront notamment présentées quelques librairies faisant parti de la boite à outil minimale des _data scientists_: `NLTK` et `SpaCy`. Les chapitres suivants permettront de se focaliser sur la modélisation du langage. 

## Méthode

L’analyse textuelle vise à transformer le texte en données
numériques manipulables. Pour cela il est nécessaire de se fixer
une unité sémantique minimale. 
Cette unité textuelle peut être le mot ou encore une séquence de *n*
mots (un *ngram*) ou encore une chaîne de caractères (e.g. la
ponctuation peut être signifiante). On parle de **token**. 

On peut ensuite utiliser diverses techniques (_clustering_,
classification supervisée) suivant l’objectif poursuivi pour exploiter
l’information transformée. Mais les étapes de nettoyage de texte sont indispensables.
Sinon un algorithme sera incapable de détecter une information pertinente dans l'infini des possibles. 


# Bases d'exemple

## Le [*Comte de Monte Cristo*](https://fr.wikipedia.org/wiki/Le_Comte_de_Monte-Cristo)

La base d'exemple est le [*Comte de Monte Cristo*](https://fr.wikipedia.org/wiki/Le_Comte_de_Monte-Cristo) d'Alexandre Dumas.
Il est disponible
gratuitement sur le site
[http://www.gutenberg.org _(Project Gutemberg)_](http://www.gutenberg.org/ebooks/author/492) comme des milliers
d'autres livres du domaine public. 

La manière la plus simple de le récupérer
est de télécharger avec le _package_ `request` le fichier texte et le retravailler
légèrement pour ne conserver que le corpus du livre : 

```{python}
#| echo: true
from urllib import request

url = "https://www.gutenberg.org/files/17989/17989-0.txt"
response = request.urlopen(url)
raw = response.read().decode('utf8')

dumas = (
  raw
  .split("*** START OF THE PROJECT GUTENBERG EBOOK LE COMTE DE MONTE-CRISTO, TOME I ***")[1]
  .split("*** END OF THE PROJECT GUTENBERG EBOOK LE COMTE DE MONTE-CRISTO, TOME I ***")[0]
) # <1>

import re

def clean_text(text):
    text = text.lower() # mettre les mots en minuscule
    text = " ".join(text.split())
    return text

dumas = clean_text(dumas)

dumas[10000:10500]
```
1. On extrait de manière un petit peu simpliste le contenu de l'ouvrage

## Le corpus anglo-saxon

Nous allons utiliser une base anglo-saxonne présentant trois auteurs de la littérature fantastique:

* [Edgar Allan Poe](https://fr.wikipedia.org/wiki/Edgar_Allan_Poe), (_EAP_) ;
* [HP Lovecraft](https://fr.wikipedia.org/wiki/H._P._Lovecraft) (_HPL_) ;
* [Mary Wollstonecraft Shelley](https://fr.wikipedia.org/wiki/Mary_Shelley) (_MWS_).

Les données sont disponibles sur un CSV mis à disposition sur [`Github`](https://github.com/GU4243-ADS/spring2018-project1-ginnyqg/blob/master/data/spooky.csv). L'URL pour les récupérer directement est 
<https://github.com/GU4243-ADS/spring2018-project1-ginnyqg/raw/master/data/spooky.csv>.


Le fait d'avoir un corpus confrontant plusieurs auteurs nous permettra de comprendre la manière dont les nettoyages de données textuelles favorisent les analyses comparatives. 

Nous pouvons utiliser le code suivant pour lire et préparer ces données:

```{python}
#| echo: true
#| output: false
import pandas as pd

url='https://github.com/GU4243-ADS/spring2018-project1-ginnyqg/raw/master/data/spooky.csv'
#1. Import des données
horror = pd.read_csv(url,encoding='latin-1')
#2. Majuscules aux noms des colonnes
horror.columns = horror.columns.str.capitalize()
#3. Retirer le prefixe id
horror['ID'] = horror['Id'].str.replace("id","")
horror = horror.set_index('Id')
```

Le jeu de données met ainsi en regard un auteur avec une phrase qu'il a écrite : 

```{python}
#| echo: true
horror.head()
```

On peut se rendre compte que les extraits des 3 auteurs ne sont
pas forcément équilibrés dans le jeu de données.
Si on utilise ultérieurement ce corpus pour de la modélisation, il sera nécessaire de tenir compte de ce déséquilibre. 

```{python}
#| echo: true
(
  horror
  .value_counts('Author')
  .plot(kind = "barh")
)
```


# Premières analyses de fréquence

L'approche usuelle en statistique, qui consiste à faire une analyse descriptive avant de mettre en oeuvre une modélisation, s'applique également à l'analyse de données textuelles. La fouille de documents textuels implique ainsi, en premier lieu, une analyse statistique afin de déterminer la structure du corpus. 

Avant de s'adonner à une analyse systématique du champ lexical de chaque
auteur, on va se focaliser dans un premier temps sur un unique mot, le mot *fear*.

## Exploration ponctuelle


::: {.cell .markdown}
```{=html}
<div class="alert alert-info" role="alert">
<h3 class="alert-heading"><i class="fa-solid fa-comment"></i> Note</h3>
```

L'exercice ci-dessous présente une représentation graphique nommée 
*waffle chart*. Il s'agit d'une approche préférable aux
camemberts (_pie chart_) qui sont des graphiques manipulables car l'oeil humain se laisse
facilement berner par cette représentation graphique qui ne respecte pas
les proportions. 

```{=html}
</div>
```
:::

::: {.cell .markdown}
```{=html}
<div class="alert alert-success" role="alert">
<h3 class="alert-heading"><i class="fa-solid fa-pencil"></i> Exercice 1 : Fréquence d'un mot</h3>
```

Dans un premier temps, nous allons nous concentrer sur notre corpus anglo-saxon (`horror`)

1. Compter le nombre de phrases, pour chaque auteur, où apparaît le mot `fear`.
2. Utiliser `pywaffle` pour obtenir les graphiques ci-dessous qui résument
de manière synthétique le nombre d'occurrences du mot *"fear"* par auteur.
3. Refaire l'analyse avec le mot *"horror"*. 


```{=html}
</div>
```
:::

```{python}
#| output: false

#1. Compter le nombre de phrase pour chaque auteur avec fear
def nb_occurrences(word, train_data):
    train_data['wordtoplot'] = train_data['Text'].str.contains(word).astype(int)
    table = train_data.groupby('Author').sum(numeric_only = True)
    data = table.to_dict()['wordtoplot']
    return table
  
table = nb_occurrences("fear", horror)
```

Le comptage obtenu devrait être le suivant

```{python}
table.head()
```

```{python}
#| output: false
import matplotlib.pyplot as plt
from pywaffle import Waffle

#2. Faire un graphique d'occurences avc pywaffle
def graph_occurrence(word, train_data):
    table = nb_occurrences(word, train_data)
    data = table.to_dict()['wordtoplot']
    fig = plt.figure(
        FigureClass=Waffle, 
        rows=15, 
        values=data, 
        title={'label': 'Utilisation du mot "%s" par les auteurs' %word, 'loc': 'left'},
        labels=[f"{k} ({v})" for k, v in data.items()]
    )
    return fig

fig = graph_occurrence("fear", horror)
```

Ceci permet d'obtenir le _waffle chart_ suivant :

```{python}
#| echo: false
#| label: fig-waffle-fear
#| fig-cap: "Répartition du terme fear dans le corpus de nos trois auteurs"

fig.get_figure()
```

On remarque ainsi de manière très intuitive
le déséquilibre de notre jeu de données
lorsqu'on se focalise sur le terme _"peur"_
où Mary Shelley représente près de 50%
des observations.

Si on reproduit cette analyse avec le terme _"horror"_, on retrouve la figure suivante:

```{python}
#| output: false

#3. Graphe d'occurences avec le mot horror
fig = graph_occurrence("horror", horror)
```

```{python}
#| label: fig-waffle-horror
#| fig-cap: "Répartition du terme horror dans le corpus de nos trois auteurs"
fig.get_figure()
```


## Transformation d'un texte en _tokens_

Dans l'exercice précédent, nous faisions une recherche ponctuelle, qui ne passe pas vraiment à l'échelle. Pour généraliser cette approche, on découpe généralement un corpus en unités sémantiques indépendantes: les _tokens_. 


::: {.cell .markdown}
```{=html}
<div class="alert alert-warning" role="alert">
<h3 class="alert-heading"><i class="fa-solid fa-lightbulb"></i> Hint</h3>
```

Nous allons avoir besoin d'importer un certain nombre de corpus prêts à l'emploi pour utiliser les librairies `NTLK` ou `SpaCy`.

Pour la première, nous allons avoir besoin de faire tourner ce code

```{.python}
import nltk
nltk.download('stopwords')
nltk.download('punkt')
nltk.download('genesis')
nltk.download('wordnet')
nltk.download('omw-1.4')
```

Pour la seconde, 

```{.python}
!python -m spacy download fr_core_news_sm
```

```{=html}
</div>
```
:::


```{python}
#| output: false
import nltk
nltk.download('stopwords')
nltk.download('punkt')
nltk.download('genesis')
nltk.download('wordnet')
nltk.download('omw-1.4')
```

```{python}
#| output: false
!python -m spacy download fr_core_news_sm
```


Plutôt que d'implémenter soi-même un _tokenizer_ inefficace, il est plus approprié d'en appliquer un issu d'une librairie spécialisée. Historiquement, le plus simple était de prendre le _tokenizer_ de `NLTK`, la librairie historique de _text mining_ en `Python`:

```{python}
#| echo: true
#| output: false
from nltk.tokenize import word_tokenize
word_tokenize(dumas[10000:10500])
```

Comme on le voit, cette librairie ne fait pas les choses dans le détail et a quelques incohérences: `j'y étais` est séparé en 4 sèmes (`['j', "'", 'y', 'étais']`) là où `l'acheter` reste un unique sème. `NLTK` est en effet une librairie anglo-saxonne et l'algorithme de séparation n'est pas toujours adapté aux règles grammaticales françaises. Il vaut mieux dans ce cas privilégier `SpaCy`, la librairie plus récente pour faire ce type de tâche. En plus d'être très bien documentée, elle est mieux adaptée pour les langues non anglo-saxonnes. En l'occurrence, comme le montre l'[exemple de la documentation](https://spacy.io/usage/linguistic-features#tokenization) sur les _tokenizers_, l'algorithme de séparation présente un certain raffinement

![Exemple d'algorithme de tokenisation](https://spacy.io/images/tokenization.svg)

Celui-ci peut être appliqué de cette manière:

```{python}
#| echo: true
#| output: false
import spacy
from spacy.tokenizer import Tokenizer
nlp = spacy.load("fr_core_news_sm")
doc = nlp(dumas[10000:10500])
for token in doc:
    print(token.text)
```

Comme on peut le voir, il reste encore beaucoup d'éléments polluants notre structuration de corpus, à commencer par la ponctuation. Nous allons néanmoins pouvoir facilement retirer ceux-ci ultérieurement, comme nous le verrons.


## Le nuage de mot: une première analyse généralisée

A ce stade, nous n'avons encore aucune appréhension de la structure de notre corpus: nombre de mots, mots les plus représentés, etc. 

Pour se faire une idée de la structure de notre corpus,
on peut commencer par compter la distribution des mots dans l'oeuvre de Dumas. Commençons par le début de l'oeuvre, à savoir les 30 000 premiers mots et comptons les mots uniques:

```{python}
#| echo: true
from collections import Counter

doc = nlp(dumas[:30000])

# Extract tokens, convert to lowercase and filter out punctuation and spaces
tokens = [token.text.lower() for token in doc if not token.is_punct and not token.is_space]

# Count the frequency of each token
token_counts = Counter(tokens)
```

Nous avons déjà de nombreux mots différents dans le début de l'oeuvre. 

```{python}
len(token_counts)
``` 

Nous voyons la haute dimensionnalité du corpus puisque nous avons près de 1500 mots différents sur les 30 000 premiers mots de l'oeuvre de Dumas. 

```{python}
#| echo: true
token_count_all = list(token_counts.items())

# Create a DataFrame from the list of tuples
token_count_all = pd.DataFrame(token_count_all, columns=['word', 'count'])
```

Si on regarde la distribution de la fréquence des mots, exercice que nous prolongerons ultérieurement en évoquant la [loi de Zipf](https://fr.wikipedia.org/wiki/Loi_de_Zipf), nous pouvons voir que de nombreux mots sont unique (près de la moitié des mots), que la densité de fréquence descend vite et qu'il faudrait se concentrer un peu plus sur la queue de distribution que ne le permet la figure suivante:


```{python}
#| echo: true
from plotnine import *
(
  ggplot(token_count_all) +
  geom_histogram(aes(x = "count")) +
  scale_x_log10()
)
```

Maintenant, si on regarde les 25 mots les plus fréquents, on peut voir que ceux-ci ne sont pas très intéressants pour analyser le sens de notre document:

```{python}
#| echo: true
# Sort the tokens by frequency in descending order
sorted_token_counts = token_counts.most_common(25)
sorted_token_counts
```

```{python}
sorted_token_counts = pd.DataFrame(sorted_token_counts, columns=['word', 'count'])
```

```{python}
(
    ggplot(sorted_token_counts, aes(x='word', y='count')) +
    geom_point(stat='identity', size = 3, color = "red") +
    scale_x_discrete(
      limits=sorted_token_counts.sort_values("count")["word"].tolist()
    ) +
    coord_flip() +
    theme_minimal() +
    labs(title='Word Frequency', x='Word', y='Count')
)
```

Nous nous concentrerons ultérieurement sur ces mots valise car il sera important d'en tenir compte pour les analyses approfondies de nos documents. 

Nous avons pu, par ces décomptes de mots, avoir une première intutition de la nature de notre corpus. Néanmoins, une approche un peu plus visuelle serait pertinente pour avoir un peu plus d'intuitions. 
Les nuages de mots (*wordclouds*) sont des représentations graphiques assez pratiques pour visualiser
les mots les plus fréquents, lorsqu'elles ne sont pas utilisées à tort et à travers. 
Les _wordclouds_ sont très simples à implémenter en `Python`
avec le module `Wordcloud`. Quelques paramètres de mise en forme
permettent même d'ajuster la forme du nuage à
une image.

::: {.cell .markdown}
```{=html}
<div class="alert alert-success" role="alert">
<h3 class="alert-heading"><i class="fa-solid fa-pencil"></i> Exercice 3 : Wordcloud</h3>
```

1. En utilisant la fonction `wordCloud`, faire trois nuages de mot pour représenter les mots les plus utilisés par chaque auteur du corpus `horror`[^random_state].
2. Faire un nuage de mot du corpus `dumas` en utilisant un masque
comme celui-ci

<details>
<summary>
Exemple de masque pour la question 2
</summary>

![URL de l'image: https://minio.lab.sspcloud.fr/lgaliana/generative-art/pythonds/book.png
](https://minio.lab.sspcloud.fr/lgaliana/generative-art/pythonds/book.png)


</details>

[^random_state]: Pour avoir les mêmes résultats que ci-dessous, vous pouvez fixer l'argument `random_state=21`. 

```{=html}
</div>
```
:::

```{python}
from wordcloud import WordCloud

#1. Wordclouds trois auteurs
def graph_wordcloud(author, train_data, varname = "Text"):
  txt = train_data.loc[train_data['Author']==author, varname]
  all_text = ' '.join([text for text in txt])
  wordcloud = WordCloud(width=800, height=500,
                      random_state=21,
                      max_words=2000,
                      background_color = "white",
                      colormap='Set2').generate(all_text)
  return wordcloud

n_topics = ["HPL","EAP","MWS"]
```

```{python}
#| fig-cap: Nuage de mot produit à partir du corpus anglo-saxon
#| label: fig-wordcloud-spooky
fig = plt.figure(figsize=(15, 12))
for i in range(len(n_topics)):
    ax = fig.add_subplot(2,2,i+1)
    wordcloud = graph_wordcloud(n_topics[i], horror)

    ax.imshow(wordcloud)
    ax.axis('off')
```

```{python}
import wordcloud
import numpy as np
import io
import requests
import PIL
import matplotlib.pyplot as plt

img = "https://minio.lab.sspcloud.fr/lgaliana/generative-art/pythonds/book.png"
book_mask = np.array(
  PIL.Image.open(io.BytesIO(requests.get(img).content))
)

def make_wordcloud(corpus):
    wc = wordcloud.WordCloud(background_color="white", max_words=2000, mask=book_mask, contour_width=3, contour_color='steelblue')
    wc.generate(corpus)
    return wc

wordcloud_dumas = make_wordcloud(dumas)
```

```{python}
#| fig-cap: Nuage de mot produit à partir du Comte de Monte Cristo
#| label: fig-wordcloud-dumas
plt.imshow(wordcloud_dumas, interpolation='bilinear')
plt.axis("off")
```


Si nous n'en étions pas convaincus, ces visualisations montrent clairement qu'il est nécessaire de nettoyer notre texte. Par exemple, en ce qui concerne l'oeuvre du Dumas, le nom
du personnage principal, Dantès, est ainsi masqué par un certain nombre d'articles ou mots de liaison qui perturbent l'analyse. 
En ce qui concerne le corpus anglo-saxon, ce sont des termes similaires, comme *"the"*, *"of"*, etc. 

Ces mots sont des 
*stop words*. 
Ceci est une démonstration par l'exemple qu'il vaut mieux nettoyer le texte avant de 
l'analyser (sauf si on est intéressé
par la loi de Zipf, cf. exercice suivant).

## Aparté: la loi de Zipf

Zipf, dans les années 1930, a remarqué une régularité statistique dans *Ulysse*, l'oeuvre de Joyce. Le mot le plus fréquent apparaissait $x$ fois, le deuxième mot le plus fréquent 2 fois moins, le suivant 3 fois moins que le premier, etc. D'un point de vue statistique, cela signifie que la fréquence d'occurrence $f(n_i)$ d'un mot est
liée à son rang $n_i$ dans l'ordre des fréquences par une loi de la forme

$$f(n_i) = c/n_i$$

où $c$ est une constante. 

Plus généralement, on peut dériver la loi de Zipf d'une distribution exponentiellement décroissante des fréquences : $f(n_i) = cn_{i}^{-k}$. Sur le plan empirique, cela signifie qu'on peut utiliser les régressions poissonniennes pour estimer les paramètres de la loi, ce qui prend la spécification suivante

$$
\mathbb{E}\bigg( f(n_i)|n_i \bigg) = \exp(\beta_0 + \beta_1 \log(n_i))
$$

Les modèles linéaires généralisés (GLM) permettent de faire ce type de régression. En `Python`, ils sont disponibles par le biais du _package_ `statsmodels`, dont les sorties sont très inspirées des logiciels payants spécialisés dans l'économétrie comme `Stata`. 

```{python}
#| echo: true
count_words = pd.DataFrame({'counter' : horror
    .groupby('Author')
    .apply(lambda s: ' '.join(s['Text']).split())
    .apply(lambda s: Counter(s))
    .apply(lambda s: s.most_common())
    .explode()}
)
count_words[['word','count']] = pd.DataFrame(count_words['counter'].tolist(), index=count_words.index)
count_words = count_words.reset_index()

count_words = count_words.assign(
    tot_mots_auteur = lambda x: (x.groupby("Author")['count'].transform('sum')),
    freq = lambda x: x['count'] /  x['tot_mots_auteur'],
    rank = lambda x: x.groupby("Author")['count'].transform('rank', ascending = False)
)
```

Commençons par représenter la relation entre la fréquence et le rang:

```{python}
#| output: false
#| echo: true
from plotnine import *

g = (
    ggplot(count_words) +
    geom_point(aes(y = "freq", x = "rank", color = 'Author'), alpha = 0.4) +
    scale_x_log10() + scale_y_log10() +
    theme_minimal()
)
```

Nous avons bien, graphiquement, une relation log-linéaire entre les deux :

```{python}
g
```

Avec `statsmodels`, vérifions plus formellement cette relation:

```{python}
#| echo: true
import statsmodels.api as sm
import numpy as np

exog = sm.add_constant(np.log(count_words['rank'].astype(float)))

model = sm.GLM(count_words['freq'].astype(float), exog, family = sm.families.Poisson()).fit()

# Afficher les résultats du modèle
print(model.summary())
```

Le coefficient de la régression est presque 1 ce qui suggère bien une relation
quasiment log-linéaire entre le rang et la fréquence d'occurrence d'un mot. 
Dit autrement, le mot le plus utilisé l'est deux fois plus que le deuxième mot le plus fréquent qui l'est trois plus que le troisième, etc. On retrouve bien empiriquement cette loi sur ce corpus de trois auteurs. 


# Nettoyage de textes

